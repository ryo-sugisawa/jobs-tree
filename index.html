<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ジョブツリー</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .node rect {
      fill: white;
      stroke: black;
      stroke-width: 2px;
    }

    .node text {
      font: 14px sans-serif;
      fill: black;
    }

    .link {
      fill: none;
      stroke: #000;
      stroke-width: 1.5px;
    }

    .highlight rect {
      stroke: red;
      stroke-width: 3px;
    }

    .blur {
      opacity: 0.4;
    }

    .tooltip {
      position: absolute;
      text-align: left;
      width: auto;
      height: auto;
      padding: 5px;
      font: 14px sans-serif;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
      pointer-events: none;
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <h1>ジョブツリー</h1>
  <svg width="800" height="600"></svg>
  <div class="tooltip" style="opacity: 0;"></div>

  <script>
    d3.json("jobs.json").then(function(data) {
      const svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

      const tooltip = d3.select('.tooltip');

      // ツリーレイアウト作成
      const treeLayout = d3.tree().size([height - 100, width - 200]);
      const root = d3.hierarchy(data, d => d.next); // "next" を子とする

      treeLayout(root);

      // 枝（リンク）描画
      svg.selectAll('.link')
        .data(root.links())
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('d', d3.linkHorizontal()
          .x(d => d.y + 100)
          .y(d => d.x + 50));

      // ノード作成
      const node = svg.selectAll('.node')
        .data(root.descendants())
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.y + 100},${d.x + 50})`);

      // 四角形の背景（幅はテキスト長に応じて動的に設定）
      node.append('rect')
        .attr('x', d => -calculateNodeWidth(d.data.name) / 2)
        .attr('y', -20)
        .attr('width', d => calculateNodeWidth(d.data.name))
        .attr('height', 40)
        .attr('rx', 5)
        .attr('ry', 5);

      // ノードのテキスト
      node.append('text')
        .attr('dy', '0.35em')
        .attr('text-anchor', 'middle')
        .text(d => d.data.name);

      // ノードクリックイベント
      node.on('click', function (event, d) {
        // 全ノードをリセット
        svg.selectAll('.node')
          .classed('highlight', false)
          .classed('blur', true);

        // クリックされたノードを除外（ぼやけさせない）
        d3.select(this)
          .classed('blur', false);

        // 次のノードのみ強調（枠を赤に変更）
        if (d.children) {
          d.children.forEach(child => {
            svg.selectAll('.node')
              .filter(nodeData => nodeData === child)
              .classed('highlight', true)
              .classed('blur', false);
          });
        }
      });

      // ノードマウスオーバーイベント（Tips表示）
      node.on('mouseover', function (event, d) {
        if (d.parent && d.parent.data.param && d.data.param) {
          // 親ノードとの差分を計算
          const parentParam = d.parent.data.param;
          const currentParam = d.data.param;
          const diffEntries = Object.entries(currentParam)
            .filter(([key, value]) => value - (parentParam[key] || 0) >= 1);

          if (diffEntries.length > 0) {
            // ツールチップの中身を設定
            const tooltipContent = diffEntries.map(([key, value]) => `${key}: +${value - parentParam[key]}`).join('<br>');
            tooltip.html(tooltipContent)
              .style('opacity', 1)
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY + 10) + 'px');
          }
        }
      });

      // ノードマウスアウトイベント（Tips非表示）
      node.on('mouseout', function () {
        tooltip.style('opacity', 0);
      });

      // ノードの幅を計算する関数（文字列の長さに応じて幅を設定）
      function calculateNodeWidth(name) {
        const padding = 20; // 左右の余白
        const charWidth = 8; // 1文字幅の目安（px単位）
        return name.length * charWidth + padding;
      }
    });
  </script>